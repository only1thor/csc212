//http://tcuc.info/md/#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
#include <iostream>
#include <cstring>
#include <random>
#include <chrono>
#include <algorithm>

int* gen_list_unsorted(int n);

void merge(int* A, int n, int mid) {
  int B[n]={0};
  for(int i=0;i<n;++i){
    // Copy Array A to B.
    B[i]=A[i];
  }
  int i=0;
  int j=mid;
  int k=0;
  for(k=0;i<mid && j<n;k++){
    if(B[j]<B[i]){
      A[k]=B[j];
      j++;
    }
    else{
      A[k]=B[i];
      i++;
    }
  }
  int *c;
  if(i<mid){
    c=&i;
  }
  if(j<n){
    c=&j;
  }
  for(;k<n;k++){
    A[k]=B[*c];
  }
}

void mergesort(int* A, int n) {
    if (n < 2) {
        return;
    }
    mergesort(A, n/2);
    mergesort(A + n/2, n/2);
    merge(A, n, n/2);
    /* Implement mergesort here */

}

int partition(int* A, int lo, int hi) {

    /* Implement partition here */
    return -1;

}

void quicksort(int* A, int lo, int hi) {

    /* Implement quicksort here */

}

/* AUXILIARY FUNCTIONS */

/* Compares int arrays of similar length n for equality */
bool compare_arrays(int* A, int* B, int n) {
    bool success = true;
    for (int i = 0; i < n; i++) {
        if (A[i] != B[i]) {
            success = false;
            break;
        }
    }
    return success;
}


/* TEST FUNCTIONS */

void custom_test(int n) {

    /* You can write your own additional tests here if you would like */

}

bool test_merge(int n, int t) {

    std::random_device sd;
    std::mt19937 generator(sd());
    std::uniform_int_distribution<int> distribution(n/20, n - (n/20));

    int mid = distribution(generator);

    int* A = gen_list_unsorted(n);
    std::sort(A, A + mid);
    std::sort(A + mid, A + n);

    int* B = new int[n];
    std::memcpy(B, A, sizeof(int)*n);
    std::sort(B, B + n);

    merge(A, n, mid);

    bool success = compare_arrays(A, B, n);

    std::cout << "Merge ";
    std::cout << ((success) ? "successful" : "failed");
    std::cout << " on trial " << t << std::endl;

    delete [] A;
    delete [] B;

    return success;

}

bool test_mergesort(int n, int t) {

    int* A = gen_list_unsorted(n);
    int* B = new int[n];
    std::memcpy(B, A, sizeof(int)*n);
    std::sort(B, B + n);

    mergesort(A, n);

    bool success = compare_arrays(A, B, n);

    std::cout << "Mergesort ";
    std::cout << ((success) ? "successful" : "failed");
    std::cout << " on trial " << t << std::endl;

    delete [] A;
    delete [] B;

    return success;

}

bool test_quicksort(int n, int t) {

    int* A = gen_list_unsorted(n);
    int* B = new int[n];
    std::memcpy(B, A, sizeof(int)*n);
    std::sort(B, B + n);

    quicksort(A, 0, n);

    bool success = compare_arrays(A, B, n);

    std::cout << "Quicksort ";
    std::cout << ((success) ? "successful" : "failed");
    std::cout << " on trial " << t << std::endl;

    delete [] A;
    delete [] B;

    return success;
}

// Generate a random, unsorted list
int* gen_list_unsorted(int size) {

    std::random_device sd;
    std::mt19937 generator(sd());
    std::uniform_int_distribution<int> distribution(-size,size);
    int* nlist = new int[size];
    for (int i = 0; i < size; i++) {
        nlist[i] = distribution(generator);
    }
    return nlist;
}

int main(int argc, char** argv) {

    /* Input validation */
    if (argc != 3) {
        std::cerr << "Invalid Arguments. Usage: test_type(str) input_size(int)" << std::endl;
        return 1;
    }
    int num_ttypes = 4;
    char test_types[4][11] = {"merge", "mergesort", "quicksort", "custom"};
    int test_idx = -1;
    for (int i = 0; i < num_ttypes; i++) {
        if (!strcmp(argv[1], test_types[i])) {
            test_idx = i;
            break;
        }
    }
    if (test_idx == -1) {
        std::cerr << "Invalid Arguments. Possibilities for test_type are:" << std::endl;
        for (int i = 0; i < num_ttypes; i++) {
            std::cout << test_types[i] << std::endl;
        }
        return 2;
    }
    if (atoi(argv[2]) <= 0) {
        std::cerr << "Invalid Arguments. Please enter a valid number n > 0." << std::endl;
        return 3;
    }

    /* Some initialization */
    int input_size = atoi(argv[2]);

    typedef bool (*test_fn)(int, int);
    test_fn tests[3] = {test_merge, test_mergesort, test_quicksort};

    char test_names[3][19] = {"Merge", "Mergesort", "Quicksort"};

    /* Run the chosen test */
    switch (test_idx) {
        case 0 :
        case 1 :
        case 2 :{
            bool success = true;
            for (int i = 0; i < 3; i++) {
                success = success && tests[test_idx](input_size, i+1);
            }
            std::cout << test_names[test_idx];
            std::cout << ((success) ? " successful " : " failed ");
            std::cout << "for input size " << input_size << std::endl;
            break;
        }
        case 3 : {
            custom_test(input_size);
            break;
        }
    }
    return 0;
}
